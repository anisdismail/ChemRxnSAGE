import torch
import torch.nn as nn


class LSTM_LM(nn.Module):

    def __init__(self, vocab_size, embedding_dim, hidden_dim, num_layers, use_cuda, dropout_prob, BOS_TOKEN, EOS_TOKEN):
        super().__init__()
        self.BOS_TOKEN = BOS_TOKEN
        self.EOS_TOKEN = EOS_TOKEN
        self.hidden_dim = hidden_dim
        self.device = torch.device("cuda" if use_cuda else "cpu")
        self.num_layers = num_layers
        self.embed = nn.Embedding(vocab_size, embedding_dim)
        self.lstm_1 = nn.LSTM(embedding_dim, hidden_dim,
                              num_layers, dropout=dropout_prob, batch_first=True)
        self.dense = nn.Linear(hidden_dim, vocab_size)
        self.dropout = nn.Dropout(p=dropout_prob)
        self.log_softmax = nn.LogSoftmax(dim=1)
        self.init_params()

    def forward(self, x):
        """
        Embeds input and applies LSTM on the input sequence.

        Inputs: x
            - x: (batch_size, seq_len), sequence of tokens generated by generator
        Outputs: out
            - out: (batch_size * seq_len, vocab_size), lstm output prediction
        """
        self.lstm_1.flatten_parameters()
        h0, c0 = self.init_hidden(x.size(0))
        emb = self.embed(x)  # batch_size * seq_len * emb_dim
        # out: batch_size * seq_len * hidden_dim
        out, _ = self.lstm_1(emb, (h0, c0))
        out = self.dropout(out)
        # (batch_size*seq_len) * vocab_size
        out = self.log_softmax(
            self.dense(out.contiguous().view(-1, self.hidden_dim)))
        return out

    def step(self, x, h, c):
        """
        Embeds input and applies LSTM one token at a time (seq_len = 1).

        Inputs: x, h, c
            - x: (batch_size, 1), sequence of tokens generated by generator
            - h: (1, batch_size, hidden_dim), lstm hidden state
            - c: (1, batch_size, hidden_dim), lstm cell state
        Outputs: out, h, c
            - out: (batch_size, vocab_size), lstm output prediction
            - h: (1, batch_size, hidden_dim), lstm hidden state
            - c: (1, batch_size, hidden_dim), lstm cell state
        """
        self.lstm_1.flatten_parameters()
        emb = self.embed(x)  # batch_size * 1 * emb_dim
        # out: batch_size * 1 * hidden_dim
        out, (h, c) = self.lstm_1(emb, (h, c))
        # batch_size * vocab_size
        out = self.log_softmax(
            self.dense(out.contiguous().view(-1, self.hidden_dim)))
        return out, h, c

    def init_hidden(self, batch_size):
        h = torch.zeros(self.num_layers, batch_size, self.hidden_dim)
        c = torch.zeros(self.num_layers, batch_size, self.hidden_dim)
        h, c = h.to(self.device), c.to(self.device)
        return h, c

    def init_params(self):
        for param in self.parameters():
            param.data.uniform_(-0.05, 0.05)

    def sample(self, batch_size, seq_len, generator, x=None):
        """
        Samples the network and returns a batch of samples of length seq_len.

        Outputs: out
            - out: (batch_size * seq_len)
        """
        # Initialize hidden states
        h, c = self.init_hidden(batch_size if x is None else x.size(0))

        # Prepare the input tensor
        if x is None:
            x = torch.full((batch_size, 1), self.BOS_TOKEN,
                           dtype=torch.int64, device=self.device)
            given_len = 0
        else:
            given_len = x.size(1)
            x = x[:, -1:]  # Start sampling from the last provided token

        # Vector to store the generated sequence
        output_samples = torch.zeros(
            batch_size, seq_len, dtype=torch.int64, device=self.device)

        if given_len > 0:
            output_samples[:, :given_len] = x.squeeze(1)

         # Mask to keep track of sequences that have not yet generated an EOS token
        active_mask = torch.ones(
            batch_size, dtype=torch.bool, device=self.device)

        for t in range(seq_len - given_len):
            if not active_mask.any():
                break  # Stop early if all sequences have generated the EOS token

            out, h, c = self.step(x, h, c)

            # Apply softmax to get probability distribution
            prob = torch.softmax(out, dim=-1)

            # Sample from the distribution
            x = torch.multinomial(prob, 1, generator=generator)

            # Store the sample in the output tensor
            output_samples[:, given_len + t] = x.squeeze(1)

            # Update active_mask to stop processing sequences that have reached EOS token
            active_mask &= (x.squeeze(1) != self.EOS_TOKEN)

            # If a sequence has hit EOS, prevent further sampling by setting x to EOS
            x = x * active_mask.unsqueeze(1)

        return output_samples


# def sample(self, batch_size, seq_len, x=None):
        """
        Samples the network and returns a batch of samples of length seq_len.

        Outputs: out
            - out: (batch_size * seq_len)
        """


"""        samples = []
        if x is None:
            h, c = self.init_hidden(batch_size)
            x = torch.full((batch_size, 1), self.bos_token, dtype=torch.int64)
            if self.use_cuda:
                x = x.cuda()
            for _ in range(seq_len):
                out, h, c = self.step(x, h, c)
                prob = torch.exp(out)
                x = torch.multinomial(prob, 1)
                samples.append(x)
        else:
            h, c = self.init_hidden(x.size(0))
            given_len = x.size(1)
            lis = x.chunk(x.size(1), dim=1)
            for i in range(given_len):
                out, h, c = self.step(lis[i], h, c)
                samples.append(lis[i])
            prob = torch.exp(out)
            x = torch.multinomial(prob, 1)
            for _ in range(given_len, seq_len):
                samples.append(x)
                out, h, c = self.step(x, h, c)
                prob = torch.exp(out)
                x = torch.multinomial(prob, 1)
        out = torch.cat(samples, dim=1)  # along the batch_size dimension
        return out
        """
